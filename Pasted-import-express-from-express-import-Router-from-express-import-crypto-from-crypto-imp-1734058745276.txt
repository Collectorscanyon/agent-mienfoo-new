import express from 'express';
import { Router } from 'express';
import crypto from 'crypto';
import { NeynarAPIClient } from '@neynar/nodejs-sdk';
import OpenAI from 'openai';

const router = Router();
const neynar = new NeynarAPIClient(process.env.NEYNAR_API_KEY!);
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// Track processed casts to avoid duplicates
const processedCasts = new Set<string>();

// Enhanced webhook handler with response generation
router.post('/webhook', express.json(), async (req: express.Request, res: express.Response) => {
  const requestId = crypto.randomBytes(4).toString('hex');
  
  try {
    console.log('Webhook received:', {
      requestId,
      timestamp: new Date().toISOString(),
      type: req.body.type,
      data: req.body.data
    });

    // Verify signature
    if (!verifySignature(req)) {
      return res.status(401).json({ error: 'Invalid signature' });
    }

    // Handle cast.created events
    if (req.body.type === 'cast.created') {
      const cast = req.body.data;
      const castHash = cast.hash;

      // Avoid processing duplicate casts
      if (processedCasts.has(castHash)) {
        return res.status(200).json({ status: 'already processed' });
      }

      // Check if the cast mentions our bot
      if (cast.text.toLowerCase().includes('@mienfoo.eth')) {
        console.log('Bot mentioned:', {
          requestId,
          author: cast.author.username,
          text: cast.text
        });

        // Generate and post response
        try {
          const response = await generateResponse(cast.text);
          await postResponse(response, cast.hash);
          
          // Mark cast as processed
          processedCasts.add(castHash);
          
          // Cleanup old processed casts (keep last 1000)
          if (processedCasts.size > 1000) {
            const toRemove = Array.from(processedCasts).slice(0, processedCasts.size - 1000);
            toRemove.forEach(hash => processedCasts.delete(hash));
          }

          console.log('Response posted successfully:', {
            requestId,
            response,
            parentHash: cast.hash
          });
        } catch (error) {
          console.error('Error posting response:', {
            requestId,
            error: error instanceof Error ? error.message : 'Unknown error'
          });
          // Still return 200 to acknowledge webhook receipt
          return res.status(200).json({ status: 'error posting response' });
        }
      }
    }

    res.status(200).json({ status: 'success' });
  } catch (error) {
    console.error('Error processing webhook:', {
      requestId,
      error: error instanceof Error ? error.message : 'Unknown error'
    });
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Verify Neynar webhook signature
function verifySignature(req: express.Request): boolean {
  const signature = req.headers['x-neynar-signature'];
  const webhookSecret = process.env.WEBHOOK_SECRET;

  if (!signature || !webhookSecret) {
    return false;
  }

  try {
    const hmac = crypto.createHmac('sha256', webhookSecret);
    const computedSignature = hmac.update(JSON.stringify(req.body)).digest('hex');
    return signature === computedSignature;
  } catch {
    return false;
  }
}

// Generate response using OpenAI
async function generateResponse(prompt: string): Promise<string> {
  const systemPrompt = `You are Mienfoo, a knowledgeable Pokémon card collector bot. 
Your responses should be concise (max 280 chars), friendly, and focus on collecting advice 
and Pokémon card knowledge. Sign your responses with /collectorscanyon`;

  const completion = await openai.chat.completions.create({
    model: "gpt-4-turbo-preview",
    messages: [
      { role: "system", content: systemPrompt },
      { role: "user", content: prompt }
    ],
    max_tokens: 100,
    temperature: 0.7
  });

  return completion.choices[0].message.content || "I'm processing your request. Please try again shortly. /collectorscanyon";
}

// Post response to Farcaster
async function postResponse(text: string, parentHash: string) {
  const maxRetries = 3;
  let lastError;

  for (let i = 0; i < maxRetries; i++) {
    try {
      await neynar.publishCast(
        process.env.SIGNER_UUID!,
        text,
        { replyTo: parentHash }
      );
      return;
    } catch (error) {
      lastError = error;
      // Wait before retrying (exponential backoff)
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
    }
  }

  throw lastError;
}

export default router;